return(mockData)
hh<-tryCatch({
mockData<-list()
mockData$"status"<-"OK"
mockData$"ef"<-"aaa"
return(mockData)
}
)
hh<-tryCatch({
mockData<-list()
mockData$"status"<-"OK"
mockData$"ef"<-"aaa"
},error = function(err){
##A global error arised (not during the processing of a particular SV)
mockData<-list()
mockData$"status"<-"ERROR"
mockData$"ef"<-"bbb"
return(mockData)
}
)
hh<-tryCatch({
mockData<-lisaat()
mockData$"status"<-"OK"
mockData$"ef"<-"aaa"
},error = function(err){
##A global error arised (not during the processing of a particular SV)
mockData<-list()
mockData$"status"<-"ERROR"
mockData$"ef"<-"bbb"
return(mockData)
}
)
View(hh)
hh<-tryCatch({
mockData<-lisaat()
mockData$"status"<-"OK"
mockData$"ef"<-"aaa"
},error = function(err){
##A global error arised (not during the processing of a particular SV)
mockData<-list()
mockData$"status"<-"ERROR"
mockData$"ef"<-"bbb"
return(mockData)
}
)
hh<-tryCatch({
##Para generar error
##mockData<-lisaat()
mockData<-list()
mockData$"status"<-"OK"
mockData$"ef"<-"aaa"
},error = function(err){
##A global error arised (not during the processing of a particular SV)
mockData<-list()
mockData$"status"<-"ERROR"
mockData$"ef"<-"bbb"
return(mockData)
}
)
mockData<-tryCatch({
##Para generar error
##mockData<-lisaat()
mockData<-list()
mockData$"status"<-"OK"
mockData$"ef"<-"aaa"
},error = function(err){
##A global error arised (not during the processing of a particular SV)
mockData<-list()
mockData$"status"<-"ERROR"
mockData$"ef"<-"bbb"
return(mockData)
}
)
mockData<-tryCatch({
##Para generar error
##mockData<-lisaat()
mockData<-list()
#mockData$"status"<-"OK"
#mockData$"ef"<-"aaa"
},error = function(err){
##A global error arised (not during the processing of a particular SV)
mockData<-list()
mockData$"status"<-"ERROR"
mockData$"ef"<-"bbb"
return(mockData)
}
)
#############
##Si passa por el error a hh se le assigna el objeto mockdata
##Pero si no passa por el error, en el try no se puede meter un return en este caso porque no hay un nivel superior al que devolver nada
##Y lo que resulta es que a hh solo se le asigna "aaa". Curioso de entender
hh<-tryCatch({
##Para generar error
##mockData<-lisaat()
mockData<-list()
mockData$"status"<-"OK"
mockData$"ef"<-"aaa"
},error = function(err){
##A global error arised (not during the processing of a particular SV)
mockData<-list()
mockData$"status"<-"ERROR"
mockData$"ef"<-"bbb"
return(mockData)
}
)
#####################
#####################
mockData<-tryCatch({
##Para generar error
##mockData<-lisaat()
mockData<-list()
mockData$"status"<-"OK"
mockData$"ef"<-"aaa"
},error = function(err){
##A global error arised (not during the processing of a particular SV)
mockData<-list()
mockData$"status"<-"ERROR"
mockData$"ef"<-"bbb"
return(mockData)
}
)
#####################
#####################
mockData<-tryCatch({
##Para generar error
##mockData<-lisaat()
mockData<-list()
mockData$"status"<-"OK"
mockData$"ef"<-"aaa"
mockData
},error = function(err){
##A global error arised (not during the processing of a particular SV)
mockData<-list()
mockData$"status"<-"ERROR"
mockData$"ef"<-"bbb"
return(mockData)
}
)
View(mockData)
shiny::runApp('Dropbox/Cantabria/PhD_Project/ScriptsPhd/ScriptsParaUsoLocal/Postre/Postre_app')
runApp('Dropbox/Cantabria/PhD_Project/ScriptsPhd/ScriptsParaUsoLocal/Postre/Postre_app')
patientResults<-masterWrapperSinglePrediction(patientInfo = patientInfo , minScore = minScore, highScore = highScore, runMode = runMode_single)
runApp('Dropbox/Cantabria/PhD_Project/ScriptsPhd/ScriptsParaUsoLocal/Postre/Postre_app')
patientResults<-masterWrapperSinglePrediction(patientInfo = patientInfo , minScore = minScore, highScore = highScore, runMode = runMode_single)
geneBreakP_Position_respectToTSS
runApp('Dropbox/Cantabria/PhD_Project/ScriptsPhd/ScriptsParaUsoLocal/Postre/Postre_app')
runApp('Dropbox/Cantabria/PhD_Project/ScriptsPhd/ScriptsParaUsoLocal/Postre/Postre_app')
runApp('Dropbox/Cantabria/PhD_Project/ScriptsPhd/ScriptsParaUsoLocal/Postre/Postre_app')
patientResults<-masterWrapperSinglePrediction(patientInfo = patientInfo , minScore = minScore, highScore = highScore, runMode = runMode_single)
runApp('Dropbox/Cantabria/PhD_Project/ScriptsPhd/ScriptsParaUsoLocal/Postre/Postre_app')
geneBreakP_Position_respectToTSS
geneBreakP_Position_respectToTSS
paint_Enhancer_WT_Secondary_TAD(tad_X_cord = tad_X_cord,
tad_Y_cord = tad_YCoord_WildTypeLine,
nEnh_other_domain = nEnh_other_domain,
geneCenter = geneCenter,
otherDomain_breakp_line_type = otherDomain_breakp_line_type,
situation = situation,
geneBreakP_Position_respectToTSS = geneBreakP_Position_respectToTSS,
patientResults = patientResults)
info_drawingSecondaryTAD<-paint_Enhancer_WT_Secondary_TAD(tad_X_cord = tad_X_cord,
tad_Y_cord = tad_YCoord_WildTypeLine,
nEnh_other_domain = nEnh_other_domain,
geneCenter = geneCenter,
otherDomain_breakp_line_type = otherDomain_breakp_line_type,
situation = situation,
geneBreakP_Position_respectToTSS = geneBreakP_Position_respectToTSS,
patientResults = patientResults)
geneBreakP_Position_respectToTSS
info_drawingSecondaryTAD<-paint_Enhancer_WT_Secondary_TAD(tad_X_cord = tad_X_cord,
tad_Y_cord = tad_YCoord_Rearrangements,
nEnh_other_domain = nEnh_other_domain,
geneCenter = geneCenter,
otherDomain_breakp_line_type = otherDomain_breakp_line_type,
situation = situation,
geneBreakP_Position_respectToTSS = geneBreakP_Position_respectToTSS,
patientResults = patientResults)
geneBreakP_Position_respectToTSS
info_drawingSecondaryTAD<-paint_Enhancer_WT_Secondary_TAD(tad_X_cord = tad_X_cord,
tad_Y_cord = tad_YCoord_WildTypeLine,
nEnh_other_domain = nEnh_other_domain,
geneCenter = geneCenter,
otherDomain_breakp_line_type = otherDomain_breakp_line_type,
situation = situation,
geneBreakP_Position_respectToTSS = geneBreakP_Position_respectToTSS,
patientResults = patientResults)
geneBreakP_Position_respectToTSS
##Info returned used to represent the rearrangement
browser()
info_drawingSecondaryTAD<-paint_Enhancer_WT_Secondary_TAD(tad_X_cord = tad_X_cord,
tad_Y_cord = tad_YCoord_WildTypeLine,
nEnh_other_domain = nEnh_other_domain,
geneCenter = geneCenter,
otherDomain_breakp_line_type = otherDomain_breakp_line_type,
situation = situation,
geneBreakP_Position_respectToTSS = geneBreakP_Position_respectToTSS,
patientResults = patientResults)
runApp('Dropbox/Cantabria/PhD_Project/ScriptsPhd/ScriptsParaUsoLocal/Postre/Postre_app')
geneBreakP_Position_respectToTSS
runApp('Dropbox/Cantabria/PhD_Project/ScriptsPhd/ScriptsParaUsoLocal/Postre/Postre_app')
geneBreakP_Position_respectToTSS
paint_Enhancer_WT_Secondary_TAD(tad_X_cord = tad_X_cord,
tad_Y_cord = tad_YCoord_WildTypeLine,
nEnh_other_domain = nEnh_other_domain,
geneCenter = geneCenter,
otherDomain_breakp_line_type = otherDomain_breakp_line_type,
situation = situation,
geneBreakP_Position_respectToTSS = geneBreakP_Position_respectToTSS,
patientResults = patientResults)
tad_X_cord
tad_Y_cord
nEnh_other_domain
geneCenter
otherDomain_breakp_line_type
situation
geneBreakP_Position_respectToTSS
patientResults
enhNumbersSize<-0.8
distance_Yaxis_EnhLabel<-2
distance_Yaxis_EnhLabel_EnhNumber<-1.3
## Let's mantain color codes by TAD position
## If TAD is on the left blue, if it is on the right orange
## Regardless whether it is the gene or the secondary domain TAD
## In order not to confound the user if > 1 gene is affected
if(tad_X_cord[1]<20){
colorTAD<-"#acdfeb"
}else if(tad_X_cord[1]>20){
colorTAD<-"#e5edb2"
}
##Painting TAD
polygon(tad_X_cord, tad_Y_cord, col = colorTAD, border = "#ffffff")
#################################################################
## Computing enh location, required to positionate breakpoints
## Afterwards if no enh... the enh are not displayed, but we need to know where are they to positionate the breakp
enhXpos<-tad_X_cord[3]-0.45
enh_x_positions<-c(enhXpos,enhXpos+0.3,enhXpos+0.6, enhXpos+0.9)
enh_y_positions<-rep.int(x=tad_Y_cord[1], times = 4)
#########################################
##Defining coordinates breakpoint line
distanceBreakpFromEnhCluster<-0.3
##get sv_type
##browser()
sv_type<-patientResults$patientInfo$TypeSV
sv_type
sv_type
sv_type=="Duplication"
situation
gene_relocated<-FALSE ##Adding it here to avoid errors downstream, requiring this variable for inv & translocations
enh_x_positions
situation=="primaryTAD_Dextral"
geneBreakP_Position_respectToTSS
situation
otherDomain_breakp_line_type
patientResults$masterSummaryResultsMatrix
View(patientResults$masterSummaryResultsMatrix)
otherDomain_breakp_line_type
geneBreakP_Position_respectToTSS
gene
View(patientResults$resultsPerPhase_secondaryInfo$PfcGw15$prefrontalCortex.txt$matrixesGenesEvaluation)
runApp('Dropbox/Cantabria/PhD_Project/ScriptsPhd/ScriptsParaUsoLocal/Postre/Postre_app')
gene
info_drawingSecondaryTAD<-paint_Enhancer_WT_Secondary_TAD(tad_X_cord = tad_X_cord,
tad_Y_cord = tad_YCoord_WildTypeLine,
nEnh_other_domain = nEnh_other_domain,
geneCenter = geneCenter,
otherDomain_breakp_line_type = otherDomain_breakp_line_type,
situation = situation,
geneBreakP_Position_respectToTSS = geneBreakP_Position_respectToTSS,
patientResults = patientResults)
gene
paint_Enhancer_WT_Secondary_TAD(tad_X_cord = tad_X_cord,
tad_Y_cord = tad_YCoord_WildTypeLine,
nEnh_other_domain = nEnh_other_domain,
geneCenter = geneCenter,
otherDomain_breakp_line_type = otherDomain_breakp_line_type,
situation = situation,
geneBreakP_Position_respectToTSS = geneBreakP_Position_respectToTSS,
patientResults = patientResults)
runApp('Dropbox/Cantabria/PhD_Project/ScriptsPhd/ScriptsParaUsoLocal/Postre/Postre_app')
runApp('Dropbox/Cantabria/PhD_Project/ScriptsPhd/ScriptsParaUsoLocal/Postre/Postre_app')
runApp('Dropbox/Cantabria/PhD_Project/ScriptsPhd/ScriptsParaUsoLocal/Postre/Postre_app')
runApp('Dropbox/Cantabria/PhD_Project/ScriptsPhd/ScriptsParaUsoLocal/Postre/Postre_app')
runApp('Dropbox/Cantabria/PhD_Project/ScriptsPhd/ScriptsParaUsoLocal/Postre/Postre_app')
patientResults<-masterWrapperSinglePrediction(patientInfo = patientInfo , minScore = minScore, highScore = highScore, runMode = runMode_single)
targetGene
medgene_entries
any(medgene_entries!="NULL")
is.na(any(medgene_entries!="NULL"))
medgene_entries
is.na(medgene_entries)==FALSE
runApp('Dropbox/Cantabria/PhD_Project/ScriptsPhd/ScriptsParaUsoLocal/Postre/Postre_app')
runApp('Dropbox/Cantabria/PhD_Project/ScriptsPhd/ScriptsParaUsoLocal/Postre/Postre_app')
runApp('Dropbox/Cantabria/PhD_Project/ScriptsPhd/ScriptsParaUsoLocal/Postre/Postre_app')
runApp('Dropbox/Cantabria/PhD_Project/ScriptsPhd/ScriptsParaUsoLocal/Postre/Postre_app')
runApp('Dropbox/Cantabria/PhD_Project/ScriptsPhd/ScriptsParaUsoLocal/Postre/Postre_app')
runApp('Dropbox/Cantabria/PhD_Project/ScriptsPhd/ScriptsParaUsoLocal/Postre/Postre_app')
source("https://raw.githubusercontent.com/vicsanga/Postre/main/Postre_wrapper.R")
source("https://raw.githubusercontent.com/vicsanga/Postre/main/Postre_wrapper.R")
source("https://raw.githubusercontent.com/vicsanga/Postre/main/Postre_wrapper.R")
source("https://raw.githubusercontent.com/vicsanga/Postre/main/Postre_wrapper.R")
source("https://raw.githubusercontent.com/vicsanga/Postre/main/Postre_wrapper.R")
source("https://raw.githubusercontent.com/vicsanga/Postre/main/Postre_wrapper.R")
source("https://raw.githubusercontent.com/vicsanga/Postre/main/Postre_wrapper.R")
shiny::runApp('Dropbox/Cantabria/PhD_Project/ScriptsPhd/ScriptsParaUsoLocal/Postre/Postre_app')
shiny::runApp('Dropbox/Cantabria/PhD_Project/ScriptsPhd/ScriptsParaUsoLocal/Postre/Postre_app')
####################################################################
## Script for HTML generation for Web with Patients Cohort Study
####################################################################
##Use maybe the Standard info only
##Loading Standard Mode PARSED results
load(file = "~/Dropbox/Cantabria/PhD_Project/Resultados/softwareObjects/multiplePatientAnalysis/StandardMode_ParsedResults_MultiplePatientAnalyses.RData")
cohort_results_standard$head_neck$patientsInfo
cohort_results_standard$head_neck$patientsInfo$patientID
InfoPatientsStandard<-unique(
c(cohort_results_standard$head_neck$patientsInfo$patientID,
cohort_results_standard$cardiovascular$patientsInfo$patientID,
cohort_results_standard$limbs$patientsInfo$patientID,
cohort_results_standard$neurodevelopmental$patientsInfo$patientID))
#########################################
## Parsing Predictions Patients
#########################################
##CHECK PATIENTS WITH ERRORS RISED IF ANY
##TAKE AS REFERENCE SCRIPT: ~/Documentos/phD/SV_app_backup/SV_LocalAnalysis_backup_21Dic_2021/MultiplePatientAnalysis/evaluatingSpecificity_OnHealthyIndividuals/Considering_Most_Of_SVs/3_ParsingResults.R
############
## Loading prediction results approach 2
load("~/Dropbox/Cantabria/PhD_Project/Resultados/softwareObjects/multiplePatientAnalysis/results_MultiplePatientAnalyses.RData")
## Loading SVs information
load("~/Dropbox/Cantabria/PhD_Project/DatosPHD/fichasPacientes/AllPatientsInfo.RData")
########################
# NOT TOUCHING FROM HERE. Use the remaining script above for all kind of prediction, either controls or pathogenic
# When doing them locally
########################
##Phenotypes to be considered
consideredPheno<-c("head_neck",
"cardiovascular",
"limbs",
"neurodevelopmental")##As more phenos considered they will appear here
###Setwd in the folder where all the app info is hosted
setwd("~/Dropbox/Cantabria/PhD_Project/ScriptsPhd/ScriptsParaUsoLocal/Postre/Postre_app/")
##############################################
##Loading Required Function
source("functions/multiple_SV_Functions/cohortResults_Parser.R")
#############
#Parsing predictions
cohort_results_hiSpe<-cohortResults_Parser(minScore = 0.8, all_patientResults = resultsPerMode$`High-Specificity`,
consideredPheno =consideredPheno,##Improve as more Phenos can be processed##consideredPheno,##Multiple Option, for now stick with head_neck
discardRelevantByBrokenGene = FALSE,
AllPatientsInfo = AllPatientsInfo )
##Me salen
InfoPatientsHiSpe<-unique(
c(cohort_results_hiSpe$head_neck$patientsInfo$patientID,
cohort_results_hiSpe$cardiovascular$patientsInfo$patientID,
cohort_results_hiSpe$limbs$patientsInfo$patientID,
cohort_results_hiSpe$neurodevelopmental$patientsInfo$patientID))
##Use maybe the Standard info only
##Loading Standard Mode PARSED results
load(file = "~/Dropbox/Cantabria/PhD_Project/Resultados/softwareObjects/multiplePatientAnalysis/StandardMode_ParsedResults_MultiplePatientAnalyses.RData")
##Use maybe the Standard info only
##Loading Standard Mode PARSED results
load(file = "~/Dropbox/Cantabria/PhD_Project/Resultados/softwareObjects/multiplePatientAnalysis/StandardMode_ParsedResults_MultiplePatientAnalyses.RData")
##Numero de pacientes en total analizados
InfoPatientsStandard<-unique(
c(cohort_results_standard$head_neck$patientsInfo$patientID,
cohort_results_standard$cardiovascular$patientsInfo$patientID,
cohort_results_standard$limbs$patientsInfo$patientID,
cohort_results_standard$neurodevelopmental$patientsInfo$patientID))
#############################
## PCA-Initial exploration
## FOR fpkms
#############################
load(file = "/home/victor/Documentos/phD/colaboraciones/sarah/rna_seq/processedFiles/sarah_rnaSeq_2021_fpkms.RData")
###############################################
##Loading relevant genes in counts script
#load(file = "/home/victor/Documentos/phD/colaboraciones/maria/rna_seq/processedFiles/test_genesSelectedCountsAnalyses.RData")
#fpkm_masterMatrix<-fpkm_masterMatrix[fpkm_masterMatrix$gene_id %in% genesCountsAnalyses,]
####################
##remvoing character columns
num_fpkm<-fpkm_masterMatrix[,-c(1,2)]
num_fpkm<-log2(num_fpkm+1) ##log2 transformation essential to get meaningful results on plots, reducing effect of hugely expressed genes
##################################
##Doing some clustering analyses
library(rafalib)
##En primer lugar vamosa calcular al distancia entre cada par de observaciones
##La funcion dist, calcula la distancia entre las filas de la matriz. Por tanto, pensad si teneis que transponer o no la matriz...
##Por defecto calcula la distancia euclidea
d <- dist(t(num_fpkm))
#View(as.matrix(d))
##Realizamos el clustering jerarquico atendiendo a las distancias calculadas entre cada par de observaciones
hc_analysis <- hclust(d)
hc_analysis
##Representamos el arbol pintado por colores
# plot(hc_analysis,labels=colnames(num_fpkm),cex=0.5)
##
tissuesColors<-c(rep.int(x = "red",times=3),
rep.int(x = "darkred",times=3),
rep.int(x = "green",times=3),
rep.int(x = "darkgreen",times=3),
rep.int(x = "blue",times=3),
rep.int(x = "darkblue",times=3),
rep.int(x = "orange",times=3),
rep.int(x = "darkorange",times=3),
rep.int(x = "brown",times=2),
rep.int(x = "black",times=2),
rep.int(x = "purple",times=2),
rep.int(x = "violet",times=2),
rep.int(x = "sienna1",times=2),
rep.int(x = "yellow3",times=2),
rep.int(x = "darkmagenta",times=2),
rep.int(x = "mediumseagreen",times=2)
)
##Plot pintando por colores
myplclust(hc_analysis, labels=colnames(num_fpkm), lab.col=tissuesColors, cex=0.5)
###Remove for pca study
# fpkm_masterMatrix<-fpkm_masterMatrix[!genesNotExpNever,]
# num_fpkm<-num_fpkm[!genesNotExpNever,]
##doing pca
fun_doingPca<-function(targetMatrix, center, scale, PC_tag1, PC_tag2){
targetRes<-prcomp(x=t(targetMatrix), center = center, scale. = scale)
plot(x=targetRes$x[,PC_tag1],
y=targetRes$x[,PC_tag2],
# pch=c(rep.int(x =19,times=3),rep.int(x =1,times=3),
#       rep.int(x =19,times=2),rep.int(x =1,times=2),
#       rep.int(x =19,times=2),rep.int(x =1,times=2)
# ),
# col=c(rep.int(x = "brown2",times=6),
#       rep.int(x = "dodgerblue",times=4),
#       rep.int(x = "forestgreen",times=4)
# ),
xlab=PC_tag1,
ylab=PC_tag2
)
text(x=targetRes$x[,PC_tag1],
y=targetRes$x[,PC_tag2],
labels = colnames(targetMatrix),
col=tissuesColors)
}
fun_doingPca(targetMatrix = num_fpkm, center = TRUE, scale = FALSE,
PC_tag1 = "PC1", PC_tag2 = "PC2")
load(file = "/home/victor/Documentos/phD/colaboraciones/sarah/rna_seq/processedFiles/sarah_rnaSeq_2021_fpkms.RData")
load(file = "/home/victor/Documentos/phD/manyFolders/colaboraciones/sarah/rna_seq/processedFiles/sarah_rnaSeq_2021_fpkms.RData")
#############################
## PCA-Initial exploration
## FOR fpkms
#############################
load(file = "/home/victor/Documentos/phD/manyFolders/colaboraciones/sarah/rna_seq/processedFiles/sarah_rnaSeq_2021_fpkms.RData")
###############################################
##Loading relevant genes in counts script
#load(file = "/home/victor/Documentos/phD/colaboraciones/maria/rna_seq/processedFiles/test_genesSelectedCountsAnalyses.RData")
#fpkm_masterMatrix<-fpkm_masterMatrix[fpkm_masterMatrix$gene_id %in% genesCountsAnalyses,]
####################
##remvoing character columns
num_fpkm<-fpkm_masterMatrix[,-c(1,2)]
num_fpkm<-log2(num_fpkm+1) ##log2 transformation essential to get meaningful results on plots, reducing effect of hugely expressed genes
##################################
##Doing some clustering analyses
library(rafalib)
##En primer lugar vamosa calcular al distancia entre cada par de observaciones
##La funcion dist, calcula la distancia entre las filas de la matriz. Por tanto, pensad si teneis que transponer o no la matriz...
##Por defecto calcula la distancia euclidea
d <- dist(t(num_fpkm))
#View(as.matrix(d))
##Realizamos el clustering jerarquico atendiendo a las distancias calculadas entre cada par de observaciones
hc_analysis <- hclust(d)
hc_analysis
##Representamos el arbol pintado por colores
# plot(hc_analysis,labels=colnames(num_fpkm),cex=0.5)
##
tissuesColors<-c(rep.int(x = "red",times=3),
rep.int(x = "darkred",times=3),
rep.int(x = "green",times=3),
rep.int(x = "darkgreen",times=3),
rep.int(x = "blue",times=3),
rep.int(x = "darkblue",times=3),
rep.int(x = "orange",times=3),
rep.int(x = "darkorange",times=3),
rep.int(x = "brown",times=2),
rep.int(x = "black",times=2),
rep.int(x = "purple",times=2),
rep.int(x = "violet",times=2),
rep.int(x = "sienna1",times=2),
rep.int(x = "yellow3",times=2),
rep.int(x = "darkmagenta",times=2),
rep.int(x = "mediumseagreen",times=2)
)
##Plot pintando por colores
myplclust(hc_analysis, labels=colnames(num_fpkm), lab.col=tissuesColors, cex=0.5)
###Remove for pca study
# fpkm_masterMatrix<-fpkm_masterMatrix[!genesNotExpNever,]
# num_fpkm<-num_fpkm[!genesNotExpNever,]
##doing pca
fun_doingPca<-function(targetMatrix, center, scale, PC_tag1, PC_tag2){
targetRes<-prcomp(x=t(targetMatrix), center = center, scale. = scale)
plot(x=targetRes$x[,PC_tag1],
y=targetRes$x[,PC_tag2],
# pch=c(rep.int(x =19,times=3),rep.int(x =1,times=3),
#       rep.int(x =19,times=2),rep.int(x =1,times=2),
#       rep.int(x =19,times=2),rep.int(x =1,times=2)
# ),
# col=c(rep.int(x = "brown2",times=6),
#       rep.int(x = "dodgerblue",times=4),
#       rep.int(x = "forestgreen",times=4)
# ),
xlab=PC_tag1,
ylab=PC_tag2
)
text(x=targetRes$x[,PC_tag1],
y=targetRes$x[,PC_tag2],
labels = colnames(targetMatrix),
col=tissuesColors)
}
fun_doingPca(targetMatrix = num_fpkm, center = TRUE, scale = FALSE,
PC_tag1 = "PC1", PC_tag2 = "PC2")
